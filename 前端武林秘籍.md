
<h1 style="color:red">css面试</h1>

css3有哪些新特性
	https://blog.csdn.net/qq_32963841/article/details/85755682 
	border-image、border-radius、box-shadow、background-size、text-shadow、transition、transform、animation等。
	CSS3的选择器 E:last-child E:nth-child(n)
	Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件
	多列布局：column-count column-gap column-rule


一、css盒模型

	css中的盒子模型包括IE盒子模型和标准的W3C盒子模型。
	参考：http://www.runoob.com/css/css-boxmodel.html

	CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：margin，border，padding，content。
	IE6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。
	要兼容低版本浏览器，目前最好的解决方案是不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。

	IE8 及更早IE版本不支持设置填充的宽度和边框的宽度属性。
	解决IE8及更早版本不兼容问题可以在HTML页面声明 <!DOCTYPE html>即可。


二、前端一像素问题（画一条0.5px的线）

	通过伪元素设置1px的边框，再用 transform: scaleY（0.5）进行缩放，然后再将它定位（absolute）。
	重点属性：position、content、border-bottom、transform: scaleY(0.5)、transform-origin: 0 0;

三、transition和animation的区别

	1、animation多两个参数 循环和动画方式
	2、transition 不能自行触发，通过hover等动作，或者结合js进行触发。animation可以自行运行
	3、transition可控性相对较弱，只能够指定起始和结束的状态，而animation可以定义多个关键帧
	4、animation在运行结束之后，需要回到初始状态
	5、transition的作用，可以用一句话来概括“平滑改变CSS值”

	暂停动画：target.style.animationPlayState = 'paused'  （默认是 running）
	动画教程：https://www.jianshu.com/p/716584b262f6 


四、不定宽高的DIV居中	

	1.使用flex  在父盒子设置 display: flex; justify-content: center; align-items: center
	2.使用css的transform  	父盒子设置:position:relative			Div 设置: position: absolute;	transform: translate(-50%，-50%);	top: 50%;	left: 50%;
	3.父盒子设置:display:table-cell; text-align:center; vertical-align:middle;			Div 设置: display:inline-block;

		
五、浮动 https://juejin.im/post/5a954add6fb9a06348538c0d

	特性：浮动元素影响的不仅是自己，他会影响周围元素对其进行环绕

    为什么要清除浮动？（解决父元素高度坍陷问题）

	一个块级元素如果没有设置 height,其 height 由子元素撑开，对子元素使用了浮动之后，子元素就会脱离文档流,
	也就是说，父级元素中没有内容可以撑开其高度，这样父级元素 height 就会被忽略，这就是所谓的高度坍塌
    
	如何清除浮动
	1.给父级元素定义高度 
	2.让父级元素也浮动 
	4.父元素设置overflow:hidden 

	最佳实践：设置伪类样式，不破坏文档流，没有副作用
	.clearfix:after {
		display: block;
		content:"";
		clear:both;
	}
	

	伪类、伪元素：https://blog.csdn.net/m0_37686205/article/details/88396191
	伪类的操作对象是文档树中已有的元素，而伪元素则在文档树外创建了一个元素。

七、position

	值：relative，static（默认值）,absolute，fixed，sticky

	absolute 会根据上一级 position 的值不为 static 进行定位，如果向上一直没有找到 position，则相对整个 body 进行定位

	fixed 相对的是视图的窗口，或者 frame 框架（setFrame 的子框架，一种html标签）

八、css选择器分类

	基本的：
		1.id选择器（id="name"）
		2.类选择器（class="head"）
		3.标签选择器（body, div, ul, li）
		4.全局选择器（*）

	复杂的：
		1.组合选择器（.head .head_logo）
		2.后代选择器 （#head .nav ul li 从父集到子孙集）
		3.群组选择器 (div, span, img {color:Red} 具有相同样式的标签分组显示)
		4.继承选择器
		5.伪类选择器（链接样式，a元素的伪类）
		6.子选择器（div>p, 带大于号>）
		7.CSS相邻兄弟选择器（h1+p, 带加号+）


九、CSS优先级

	!important > 行内样式 > ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性

	同一级别：后写的会覆盖先写的

 	css 选择器的解析原则：从右往左进行匹配，这样可以尽早的过滤掉一些不必要的样式规则和元素
	

十、对于行内元素
	
	font-size 指定 他们的 content area 的高度，由于 inline box = 上下的 helf-leading，如果 leading 为0，在这种情况下，font-size 指定了 inline box 的高度

	font-size 指的是字体的高度，但是不能指定每个字形给定字体高度下的实际高度，导致了 span 的高度大于 line-height


十一、z-index属性

	z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的上面。
	position的值的属性大于z-index   Z-index 仅能在定位元素上奏效（例如 position:absolute;）
	元素可拥有负的 z-index 属性值


十二、块元素和行内元素

	1.块元素会独占一行，默认情况下，其宽度自动填满父元素宽度 行元素不会占据一行，会一直排在一行，直到一行排不下
	2.行元素没有宽度和高度属性，块级元素即使设置了宽度，还是会独占一行
	块级元素：div p form ul li h1-h6
	行内元素：span img input a i


十三、如何画一个三角形

	width: 0;
	height: 0;
	border-bottom: 100px solid cyan;
	border-left: 50px solid transparent;
	border-right: 50px solid transparent;


十四、伪类：

	link: 表示链接正常情况下（即页面加载完成时）显示的颜色
	visited: 链接被点击时显示的位置
	hover: 表示鼠标悬停时显示的颜色
	focus：元素获得光标焦点时的颜色
	active: 元素处于激活状态
	link -> visited -> hover -> focus -> active


十六、使元素消失的方法

	opacity：0、visibility:hidden、display:none
	1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发
	2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件
	3.display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉
	
十七、如何避免回流或将它们对性能的影响降到最低？
	1、尽可能在DOM树的最末端改变class
	2、避免设置多层内联样式
	3、动画效果应用到position属性为absolute或fixed的元素上
	4、避免使用table布局
	5、牺牲平滑度换取速度
	6、避免使用CSS的JavaScript表达式

DOM API:
	document.getElementById(id)
	document.getElementsByTagName(name)
	document.createElement(name)
	parentNode.appendChild(node)
	element.innerHTML
	element.style.left
	element.setAttribute()
	element.getAttribute()
	element.addEventListener()


<h1 style="color:red">布局面试</h1>

响应式：用一套代码去兼容不同分辨率的显示器。
自适应：开发多套界面来适应不同+分辨率的终端。缺点：屏幕太小会发生内容过于拥挤。


一、两边两栏宽度固定，中间栏宽度自适应

	参考：https://www.jianshu.com/p/f9bcddb0e8b4
		 https://blog.csdn.net/wangchengiii/article/details/77926868

	双飞翼布局：圣杯布局和双飞翼布局很相似，但 DOM 结构略有不同：
		<div class="container">
			<div class="middle">
				<div class="content">main</div>
			</div>
			<div class="left">left</div>
			<div class="right">right</div>
		</div>

		.middle, .left, .right{ height: 100px;  float: left; }
		.middle{ width: 100%; }
		.content{ background-color: deeppink;  margin: 0 200px; }
		.left{ width: 200px;  margin-left:-100%;  background-color: blue; }
		.right{ width: 200px;  margin-left: -200px;  background-color: darkorchid; }

	圣杯布局：原理就是 margin 负值法，但是有个缺陷，当页面宽度太小时，结构就崩了，结构如下：
		<div class="container"> 
		　　<div class="middle">middle</div> 
		　　<div class="left">left</div> 
		　　<div class="right">right</div> 
		</div>

		.container{ padding: 0 200px; }
		.middle, .left, .right{ position: relative;  height: 100px;  float: left; }
		.middle{ width: 100%;  background-color: deeppink; }
		.left{ left: -200px;  width: 200px;  margin-left:-100%;  background-color: blue; }
		.right{ right: -200px;  width: 200px;  margin-left: -200px;  background-color: darkorchid; }

	flex布局：
		<div class="container">
			<div class="left">left</div>
			<div class="middle">middle</div>
			<div class="right">right</div>
		</div>

		.container{ display: flex; }
		.left{ width: 200px; /* flex-basis: 200px; */  background-color: blue; }
		.middle{ width: 100%; /* flex-grow: 1; */  background-color: red; }
		.right{ width: 200px; /* flex-basis: 200px; */  background-color: green; }


flex 布局
	Flex 是 Flexible Box 的缩写，意为"弹性布局"；
	容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的
	开始位置叫做cross start，结束位置叫做cross end。
	项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。

	容器的属性：
	flex-direction：row | row-reverse | column | column-reverse;
	flex-wrap（默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。）：nowrap | wrap | wrap-reverse，默认不换行nowrap；
	flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
	justify-content（定义了项目在主轴上的对齐方式）：flex-start | flex-end | center | space-between | space-around;
	align-items（定义项目在交叉轴上如何对齐）：flex-start | flex-end | center | baseline | stretch；
	align-content（属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。）：flex-start | flex-end | center | space-between | space-around | stretch;

	项目的属性：
	order：order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
	flex-grow:属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
	flex-shrink：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
	flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）
	flex:flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。
	align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。


二、左边定宽，右边自适应

	方案一：左边设置浮动，右边宽度设置100%  .left{float:left}  .right:{width:100%}
	方案二：左设置浮动，右用calc去补宽度计算 .left{float:left} .right:{width:cacl(100vw-200px}
	方案三：父容器设置display：flex  right部分是设置flex：1
	方案四：右边div套个包裹、并前置、左及包裹 双浮动


三、水平居中

	行内元素居中（父元素 text-align: center）
	块状元素居中（块状元素没法用 text-align）
		1、宽度一定：margin:auto
		2、宽度不定：块级变行内，然后在父上 text-aligin: center


四、BFC https://juejin.im/post/5909db2fda2f60005d2093db

	理解：BFC 是 css 布局的一个概念，是一块独立的渲染区域，一个环境，里面的元素不会影响到外部的元素

	如何生成BFC：（脱离文档流：文档流分为定位流、浮动流和普通流三种）
		1、根元素，即HTML元素（最大的一个 BFC）
		2、float 的值不为 none
		3、position 的值为 absolute 或 fixed
		4、overflow 的值不为 visible（默认值。内容不会被修剪，会呈现在元素框之外）
		5、display 的值为 inline-block、table-caption、flex

	BFC布局规则：
		1.内部的 Box 会在垂直方向，一个接一个地放置。
		2.属于同一个 BFC 的两个相邻的 Box 的 margin 会发生重叠
		3.BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此, 文字环绕效果，设置 float
		4.BFC 的区域不会与 float box 重叠。
		5.计算 BFC 的高度，浮动元素也参与计算

	BFC作用：
		1.自适应两栏布局
		2.可以阻止元素被浮动元素覆盖
		3.可以包含浮动元素---清除内部浮动 原理:：触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内
		4.分属于不同的BFC时，可以阻止margin重叠
	

<h1 style="color:red">js面试</h1>


一、 this的指向

	1.当函数作为对象的方法被调用时，this就会指向该对象。
	2.作为普通函数，this指向window。
	3.构造器调用，this指向返回的这个对象。
	4.this的隐式丢失
	5.箭头函数  箭头函数的this绑定看的是this所在函数定义在哪个对象下，就绑定哪个对象，如果有嵌套的情况，则this绑定到最近的一层对象上。

	this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。

	怎么改变this的指向呢？ 1.使用es6的箭头函数；2.在函数内部使用that = this；3.使用apply，call，bind； 4.new实例化一个对象


二、什么是闭包和原型链

	简单来说就是内部函数可以访问外部函数的参数和变量。（作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁）定义私有的方法和变量，避免全局变量的污染
   	闭包的缺陷：闭包的缺点就是常驻内存会增大内存使用量，并且使用不当容易造成内存泄漏，并且影响性能。

   	内存溢出和内存泄漏（给的不够用| 用了不归还）
	内存溢出：在程序中申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出
	内存泄漏：在程序申请内存后，无法释放已申请的内存空间，一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，无论多少内存，迟到会被占光

   	举列子：闭包中的this,对象函数。匿名函数返回函数return function
 
   	作用域：(由当前环境与上层环境一系列的变量对象组成！！！保证 当先执行环境里，有权访问的变量和函数是有序的，作用域链变量只能被向上访问)
	定义：由当前环境与上层环境的一系列变量对象组成(函数嵌套函数，内部一级级往上有序访问变量或对象)
	作用是：保证当前执行环境里，有权访问的变量和函数是有序的，作用域链的变量只能被向上访问变量访问到window对象及被终止，作用域链向下访问是不允许的
		1.改变作用域有 with try..中的catch，
		2.所有为定义的直接赋值的变量自动声明为全局作用域

	作用域：一套规则，管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称查找变量（标识符就是变量或者函数名）（只用全局作用域和局部作用域）（作用域在它创建的时候就存在了）

	代码执行分为两个阶段：
		1.代码编译阶段：有编译器完成，将代码翻译可执行的代码，这个阶段会被确定
		2.代码执行阶段：有js引擎完成，主要执行可执行的代码，这个阶段执行上下文被创建（对象被创建）
	
	执行上下文：一个看不见的对象，存在若干个属性和变量，它被调用的时候创建的。函数被调用查看的this指向的object，object就是上下文（只有被调用的时候创建）

   	作用域链: https://blog.csdn.net/yooungt13/article/details/20581635
	    · 当代码在一个环境中执行时，会创建变量对象的一个作用域链,
		举例子：var name ="Tom"
			function sayHi () {
			    alert('Hi,'+name)
			}
			sayHi()  //Hi, Tom
		函数sayHi()的执行环境为全局环境，所以它的变量对象为window。当函数执行到name时，先查找局部环境，找到则换回，否则顺着作用域查找，在全局环境中，
		找到name返回，这一查找变量的有序过程的依据就是作用域。
	
	    · 作用域链是保证执行环境有权访问的所有变量和函数的有序访问

   	原型链：为了实现继承，还有一个原型链指针_proto_,
	   该指针是指向上一层的原型对象 prototype，而上一层的原型对象的结构依然类似。因此可以利用_proto_一直指向Object的原型对象上，而Object原型对象用Object.prototype.__proto__ = null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本方法


二、prototype与__proto__区别

	参考：https://blog.csdn.net/ligang2585116/article/details/53522741
	__proto__是每个对象都有的一个属性，而prototype是函数才会有的属性!!! 
	使用Object.getPrototypeOf()代替__proto__!!!
	对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。
	

三、类的创建和继承

	（es5）new 一个function，在这个function的prototype里增加属性和方法, 类里面有方法和属性
	（es6）中class, extends
	1. 继承：
 		原型链继承： 
			function Animal(){ }
			Animal.prototype.say = function() { console.log('haha'); }
			function Cat(){ } 
			Cat.prototype = new Animal(); 
			Cat.prototype.name = 'cat'; 无法实现多继承

		构造继承：使用父类的构造函数来增强子类实例。
			function Animal(){ this.say = function() { console.log('haha'); } }
			function Cat(name){ Animal.call(this); } 
			无法继承父类原型链上的属性跟方法  
		
		实例继承：为父类实例添加新特性，作为子类实例的返回
		拷贝继承：拷贝父类元素上的属性跟方法
		组合继承：构造继承 + 原型继承的组合体
		寄生组合继承：通过寄生方式，在构造继承上加一个Super函数(没有实例和方法) 让他的原型链指向父类的原型链，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性

	2.给两个构造函数A和B，如何实现A继承B （Object.prototype）
		function A(....){} A.prototype...
		function B(....){} B.prototype...
		A.prototype = Object.create(B.prototype)  在A的构造函数里new B(props)		
	
	使用new一个函数的话，函数里的构造函数的参数就为undefined，里面的一些函数可能执行错误，因为this改变了	
	Object.create =  function (o) {
		var F = function () {};
		F.prototype = o;
		return new F();
	};

	寄生组合式继承：那组合指的是什么？我的理解就是这两部分的组合：构造函数属性的继承和建立子类和父类原型的链接。

	function inheritPrototype(subType, superType){
		var prototype = Object.create(SuperType.prototype)
		prototype.constructor = subType; //增强对象
		subType.prototype = prototype; //指定对象  
	}

	function SuperType(name){
		this.name = name;
	}
	SuperType.prototype.sayName=function(){ console.log(this.name) }

	function SubType(name, age){
		SuperType.call(this, name);
		this.age = age;
	}
	inheritPrototype(SubType, SuperType);

		
四、异步回调（如何解决回调地狱）

	promise、generator、async/await
	
	promise： 
		1、是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并为这个事件提供统一的api，供异步处理
		2、有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱
		3、promise代表一个异步状态，有三个状态pending（进行中），fulfilled（完成），rejected（失败）
		4、一旦状态改变，就不会再变。任何时候都可以得到结果。从进行中变为已完成或者失败
		promise.all() 里面状态都改变，那就会输出，得到一个数组
		promise.race() 里面只有一个状态变为rejected或者fulfilled即输出
		promise.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）


promise和async/await区别
	promise解决了回调地狱，async/await则进一步优化了then链。
	async函数可以让代码简洁很多；
	Async/Await 让 try/catch 可以同时处理同步和异步错误；
	使用aync/await的话，catch能处理JSON.parse错误；
	async/await能够使得代码调试更简单；
	async函数是Generator函数的语法糖，它实现了自己的自执行器。Generator分段执行，里面的yield是暂停的标记，交出函数执行权。
	await将return值包装成promise；
	async函数调用不会造成代码阻塞，但是await会引起async函数内部代码阻塞；
	可以说，async函数完全可以看作多个异步操作，包装成的一个Promise 对象，而await命令就是内部then命令的语法糖。

	1 promise是ES6，async/await是ES8
	2 async/await相对于promise来讲，写法更加优雅
	3 reject状态：
		1）promise错误可以通过catch来捕捉，建议尾部捕获错误，
		2）async/await既可以用.then又可以用try-catch捕捉

	协程：
	协程(coroutine)，意思是多个线程相互协作，完成异步任务。
	它的运行流程如下
	协程A开始执行
	协程A执行到一半，暂停执行，执行的权利转交给协程B。
	一段时间后B交还执行权
	协程A重得执行权，继续执行


五、前端事件流

	https://www.cnblogs.com/lionisnotkitty/p/7240077.html

	一个完整的JS事件流是从window开始，最后回到window的一个过程

	事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。
	  	1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到<html>再到<body>就停止了。
		2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。
		3、冒泡阶段：事件又传播回文档
		阻止冒泡事件event.stopPropagation()
			function stopBubble(e) {
				if (e && e.stopPropagation) { // 如果提供了事件对象event 这说明不是IE浏览器
					e.stopPropagation()
				} else {
					window.event.cancelBubble = true //IE方式阻止冒泡
				}
			}
		阻止默认行为event.preventDefault()

	function stopDefault(e) {
		if (e && e.preventDefault) {
			e.preventDefault()
		} else {
			// IE浏览器阻止函数器默认动作的行为
			window.event.returnValue = false
		}
	}

	事件如何先捕获后冒泡？
	在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。
		
	哪些事件不支持冒泡事件：
		鼠标事件：mouseleave  mouseenter
		焦点事件：blur focus
		UI事件：scroll resize


六、事件委托（提高性能）

	简介：事件委托指的是，不在事件的（直接dom）上设置监听函数，而是在其父元素上设置监听函数。通过事件冒泡，父元素可以监听到子元素上事件的触发通过判断事件发生元素DOM的类型，来做出不同的响应。
	举例子： 最经典的就是ul和li标签的事件监听，比如我们在添加事件的时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加
	好处：比较适合动态生成元素的事件绑定，便于维护，性能更好。

	e.target / e.srcElement / e.toElement 都是指事件的最原始起点，比如 ul 下的某个 li。
	

七、js的new操作符做了什么？

	(1) 创建一个新对象； 
	(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 
	(3) 执行构造函数中的代码（为这个新对象添加属性）
	(4) 返回新对象。
	如果不要父类的属性跟方法，在函数的prototype上去new这个父类。


八、改变函数内部this指针的指向(bind,apply,call)

	通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2...这种形式。
	bind 返回一个函数，并不会立即执行 第二个是带参数，第一个参数要指向的this，后面的的参数用来传递


九、深拷贝和浅拷贝 https://juejin.im/post/5b00e85af265da0b7d0ba63f 从堆和栈都是内存中划分出来用来存储的区域开始讲起

	基本类型：undefined,null,Boolean,String,Number,Symbol 在内存中占据固定大小，保存在栈内存中
	引用类型：Object,Array,Date,Function,RegExp等	引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。
	基本类型的复制: 其实就是创建了一个新的副本给将这个值赋值给新变量，改变值旧对象不会改变
	引用类型的复制： 其实就是复制了指针，这个最终都将指向同一个对象，改变其值新对象也会改变
	基本类型的比较 == 会进行类型转换

	浅拷贝：仅仅就是复制了引用，彼此操作不影响，slice() concat()  object.assign
	深拷贝：在堆中重新分配内存，不同的地址，相同的值,互不影响的 JSON.parse()将一个js对象序列化为一个json字符串  JSON.stringify()将json字符串反序列化为一个js对象  es6的展开 {...}
	深拷贝和浅拷贝的主要区别是：在内存中的存储类型不同
	浅拷贝：重新在堆栈中创建内存，拷贝前后对象的基本类型互不影响。只拷贝一层，不能对对象进行子对象进行拷贝
	深拷贝：对对象中的子对象进行递归拷贝，拷贝前后两个对象互不影响
	

十、跨域

	参考：https://segmentfault.com/a/1190000015597029

	同源策略（协议+端口号+域名要相同）
	1、jsonp跨域(只能解决get）https://blog.csdn.net/u011897301/article/details/52679486
		原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容
		步骤：1.去创建一个script标签
		      2.script的src属性设置接口地址
		      3.接口参数，必须要带一个自定义函数名，要不然后台无法返回数据
		      4.通过定义函数名去接受返回的数据    	
		
	1.jsonp 需要目标服务器配合一个callback函数。jsonp 原理：https://www.cnblogs.com/soyxiaobi/p/9616011.html 
　　2.window.name+iframe 需要目标服务器响应window.name。
　　3.window.location.hash+iframe 同样需要目标服务器作处理。
　　4.html5的 postMessage+ifrme 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。
　　5.CORS  需要服务器设置header ：Access-Control-Allow-Origin。
　　6.nginx反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求。


正向代理和反向代理：
	正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端。
	反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端。


nginx 优势：
	1、Nginx处理静态文件、索引文件，自动索引的效率非常高（静态资源缓存在 nginx 指定目录下，然后通过 IP + 路径访问）；
	2、可以实现无缓存的反向代理加速，提高网站运行速度；
	3、作为负载均衡服务器；
	4、支持高并发；
	5、CPU与内存资源占用少;
	6、支持热部署；


nginx 配置：
	1、main：用于进行nginx全局信息的配置
	2、events：用于nginx工作模式的配置
	3、http：用于进行http协议信息的一些配置
	4、server：用于进行服务器访问信息的配置
	5、location：用于进行访问路由的配置
	6、upstream：用于进行负载均衡的配置


十一、图片的懒加载和预加载

	预加载：提前加载图片，当用户需要查看时可以直接从本地缓存中渲染
	为什么要使用预加载：在网页加载之前，对一些主要内容进行加载，以提供用户更好的体验，减少等待时间。否则，如果一个页面的内容过于庞大，会出现留白。
	解决页面留白的方案：1.预加载  2.使用svg占位图片，将一些结构快速搭建起来，等待请求的数据来了之后，替换当前的占位符
	实现预加载的方法：
		1.使用html标签
		2.使用Image对象
		3.使用XMLHTTPRequest对像，但会精细控制预加载过程

	懒加载（lazyload）：客户端优化，减少请求数和延迟请求数
		提升用户体验，
		减少无效资源的加载
		防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用
	原理：首先将页面上的图片的src属性设置为空字符串，而图片的真实路经则设置带data-original属性中，
	当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入到可视区域
	，如果图片在可视区域将图片的src属性设置为data-original的值，这样就可以实现延迟加载。	


十二、函数节流防抖

	什么是防抖：短时间内多次触发同一个事件，只执行最后一次，或者在开始时执行，中间不执行。比如公交车上车，要等待最后一个乘客上车
    什么是节流：节流是连续触发事件的过程中以一定时间间隔执行函数。节流会稀释你的执行频率，比如每间隔1秒钟，只会执行一次函数，无论这1秒钟内触发了多少次事件
	都为解决高频事件而来， scroll mousewhell mouseover touchmove onresize


十三、将arguments类数组转化为数组的方法

	Array.apply(null, arguments)
	Array.prototype.slice.apply(arguments)
	Array.from(arguments)


十四、高阶函数

	一、函数作为参数传递 抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中。这样一来可以分离业务代码中变化与不变的部分
		回调函数
	二、函数作为返回值传递


十五、如何判断一个变量是对象还是数组（Object.prototype.toString.call()）。

	千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。
	typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。
	对于引用类型：除function，都返回object   null返回object。
	instanceOf() 用来判断A是否是B的实例， instanceOf 检查的是原型。
	toString() 是Object的原型方法，对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。
	hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。
	isProperty()方法测试一个对象是否存在另一个对象的原型链上。

	
十六、setTimeout 和 setInterval的机制

	因为js是单线程的。浏览器遇到setTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的
	待执行事件队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码


十七、var let const

	const：定义的变量不可修改，必须初始化 ，
	var：定义的变量可以修改，如果不初始化输出undefined，不会报错
	let：块级作用域，函数内部使用let定义后，函数外部无影响
	let const 不会造成变量的提升


十八、js垃圾回收机制

	1.JS具有自动垃圾收集的机制
	2.JS的内存生命周期（变量的生命）
		a.分配你所需要的空间 var a = 20
		b.使用分配带的内存（读写） alert（a + 10）
		c.不适用的时候，释放内存空间 a = null 
	3.JS的垃圾收集器每隔固定的时间就执行一次释放操作，通用的是通过标记清除的算法
	4.在局部作用域中，垃圾回收器很容易做出判断并回收，全局比较难，因此应避免全局变量

	标记清除算法：js最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将他标记为'进入环境'，
			当变量离开（函数执行完后），就其标记为'离开环境'。
			垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。
			而在此之后再被加上标记的变量将被视为准备删除的变量


二十四、函数的柯里化

	https://cnodejs.org/topic/5884574e250bf4e2390e9e99
	https://www.cnblogs.com/pigtail/p/3447660.html
	https://www.jianshu.com/p/f88a5175e7a2
	概念：一个函数接受函数A作为参数，运行后返回一个新的函数，并且可以处理A中的参数（只接受单一参数的函数）
	意义：将函数完全变成了接受一个参数，返回一个参数的固定形式，便于讨论和优化

	function plus (n) {
		var p = function (m) {
			return plus(n + m);
		}

		p.toString = function () {
			return n;
		}

		return p;
	}


二十六、TypeScript的优点：

	1、编译时的强类型，变成了强类型语言，还是编译成js 编译的时候就可以检验
	2、更好的模块化
	3、更好的实现面向对象的编程，类、接口、模块

	http://www.srcmini.com/3507.html 
	js项目如何升级为ts？有何影响？
	ts 基础类型都哪些，他们跟js的区别
	ts为什么会流行？与ECMA新规范的关系？
	tslint都能配置哪些功能？对开发流程有何影响？
	如何使用js实现类型约束，枚举等特性么？
	如何理解接口，泛型?
	接口是对行为的抽象，只定义属性、空方法等，具体实现由类去实现。
	泛型是指在编译阶段无法确定类型，要在执行的时候才能确定。


二十七、js的阻塞特性：

	新一代浏览器都支持并行下载JS，但是JS下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。
	css阻塞：因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。
	而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。
	

二十八、meta元素可提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词

	meta name="keyword" 告诉搜素引擎网页的关键词
	meta name="description" 告诉搜素引擎站点的内容
	mata name="author" content="name"站点制作者
	meta name="viewport" content="width=device-width, initial-scale=1.0 响应式页面					


二十九、splice和slice、map和forEach、 filter()、reduce()的区别

	1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组方法，注意：该方法不会更新原数组，而是返回一个子数组
	2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）
		splice(index, howmany,item1,...itemx)
			·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置
			·howmany参数：必须，要删除的数量，
			·item1..itemx:可选，向数组添加新项目
	3.map()：会返回一个全新的数组。适用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据
	4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素
	5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值
	6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理	



<h1 style="color:red">node面试</h1>


一、koa中间件执行机制

	1.添加中间件的方式是使用Koa实例的use方法，并传入一个generator函数，这个generator函数接受一个next参数
	2.use的原理：function Application () {this.middleware = [] // 这个数组就是用来装一个个中间件的}
	3.每次执行use方法，就把外面传进来的generator函数push到middleware数组中
		app.use = function (fn) {this.middleware.push(fn)}
	4.koa中是预先通过use方法，将请求可能会经过的中间件装在一个数组中。
	5.callback函数就是请求到来的时候执行的回调。把装着中间件middleware的数组作为参数传递为compose这个方法。
	6.compose把毫无关系的一个个中间件给收尾串起来了，就好比我们平常的烤面筋
	7.compose将中间件从最后一个开始处理，并一直往前直到第一个中间件。其实最关键的就是将最后一个中间件得到generator
	   作为参数传递给前一个中间件。当最后一个中间件的参数next是空的generator函数生成对象

	中间件是怎么跑起来的：https://juejin.im/post/591c8b4544d904006c90a2cb


二、koa和express的区别

	1.异步流程的控制。express采用callback来处理异步，koa2采用的是async/await
	2.错误处理。express采用callback捕获异常，对深层次的异常捕获不了。koa采用try/catch							



<h1 style="color:red">vue面试</h1>

加快 vue 项目的开发速度：https://juejin.im/post/6844903735668244488


如何添加动态路由 addRoutes


Vue 从 new 开始一直到渲染成最终 DOM 的过程
	https://blog.csdn.net/github_39452758/article/details/105953432 
	vue 源码包含 
	compiler：编译相关（将模板解析成 AST 语法树，代码生成）
	core：核心代码（内置组件、全局 API 封装，Vue 实例化、Obsever、Virtual DOM、工具函数 Util）
	platforms：不同平台的支持（生产 WEB 和 WEEX 平台支持的js）
	server：服务端渲染（服务端渲染相关的逻辑）
	shared：共享代码（定义浏览器端的 Vue.js 和服务端的 Vue.js 所共享的函数）

	new Vue的时候，会调用 this._init 方法， 通过该方法，合并配置、初始化生命周期、初始化事件中心、初始化渲染、初始化data 、props、computed、watcher、event、state等等，完了之后如果检测到 el 属性，则调用 vm.$mount 方法挂载vm, 所有的vue组件不论写的是 el 或者 template 属性进行渲染最终都需要编译为 render 函数，这个函数主要是通过 createElement 方法创建虚拟 DOM，为了把虚拟 DOM 转换为真实 DOM，它会在首次渲染和数据更新的时候去调用_update方法，其核心实现就是其中的_patch()方法，_patch 主要是对比前后两棵虚拟 DOM 树，找出差异的部分，然后更新到页面。
	总结渲染流程：new Vue - init - $mount - compile - render - vnode - patch - dom

vue 模板编译原理：
	https://www.jianshu.com/p/77717a3bfb17 
	整体逻辑主要分为三步：
	1、将模版字符串转换成element ASTs(解析器)；（AST 其实就是一个 js 对象，包含 tag: div, type: 1, children: [] 等）
	2、对AST进行静态节点标记，主要用来做虚拟DOM的渲染优化(优化器)；
	3、使用element ASTs生成render函数代码字符串(代码生成器)。
	一个组件的模板会被编译成一个渲染函数。每个组件有一个Watcher用来监听模板中所使用到的数据，当这些数据发生变化时，生成一份新的虚拟DOM，和原来的虚拟DOM做比对，然后更新不同的地方。


自定义指令（lazy-load 指令）
	https://cn.vuejs.org/v2/guide/custom-directive.html 
	https://www.cnblogs.com/mdengcc/p/6773672.html 
	window.screen.height 获取屏幕的高度
	ele.getBoundingClientRect().top;
	我们可以在一个单独的 js 文件里封装一个指令，Vue.directive('lazyload',{})，然后在 inserted、update 这两个钩子上调用一个函数，
	这个执行函数里通过监听滚动 window.addEventListner('scroll')，当该元素快要滚动到可视区的时候 ele.getBoundingClientRect().top - window.screen.height 小于一定值的时候，
	我们就去创建一个 Image 对象并加载图片，然后在 onload 事件回调里将这个元素的 src 设置为这个图片的 src，这样就大体实现了这个指令的主要功能，
	然后要用的时候就在入口文件导入这个 js 模块，并 Vue.use。


v-for  key 为什么？
	https://cn.vuejs.org/v2/api/#key 
	https://blog.csdn.net/qq_42164670/article/details/88959580 
	key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。
	不加key的话，更新机制的进行 diff 的时候是会全部比较的，比如删除第一个的话，导致后面的元素都不一样，会一项一项的比较。
	然后全部元素都替换，没有做到最小更新。所以这个 key 值对数据改变之后的 diff 更新比较有很大的性能提升


Vue 2.0:
	https://www.cnblogs.com/theblogs/p/10634101.html
	https://www.cnblogs.com/chenwenhao/p/11258895.html
	https://www.jianshu.com/p/46c9d777cab1


mixin 混入原理？
	https://cn.vuejs.org/v2/guide/mixins.html#%E5%9F%BA%E7%A1%80 
	类似于小程序的 behaviors。


v-model：
	1、接受一个 value prop；
	2、value 改变时 emit 一个 input 事件。


一、介绍下MVVM(数据的双向绑定）

	vue的双向绑定原理：采用数据劫持 + 发布/订阅者模式。
	M: model数据模型
	V: view 界面
	VM:作为桥梁负责沟通view跟model
    只关心数据的流转，减少强耦合性。最关键的就是数据的双向绑定
 	关键步骤：
		1、实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
		2、实现一个指令解析器 Compile，对每个元素指令模板替换数据，以及绑定相应的更新函数
		3、实现一个 Watcher 来连接 Observer 和 Compile，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图

	mvc和mvvm区别:
	http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html
	mvc:
	a、View 传送指令到 Controller，Controller 完成业务逻辑后，要求 Model 改变状态，Model 将新的数据发送到 View，用户得到反馈。
	b、controller 收到指令，修改 Model，然后将新的数据发送到 View。

	mvvm不同点:
	a、各部分之间的通信，都是双向的。
	b、View 与 Model 不发生联系，通过 VM 层进行传递。
	c、View 非常薄，不部署任何业务逻辑，所有逻辑在 VM 层。View的变动，自动反映在 ViewModel，反之亦然。


二、 eventBus vuex
	https://zhuanlan.zhihu.com/p/72777951

	import Vue from 'vue'
	export const EventBus = new Vue()

	EventBus.$emit("aMsg", '来自A页面的消息');
	EventBus.$on("aMsg", (msg) => {})

 	原理：eventbus 解决了兄弟组件之间事件传递问题,本质是订阅发布者模式，从而摆脱了兄弟之间需要父组件转而传递的复杂。

	如果使用不善，EventBus会是一种灾难，到底是什么样的“灾难”了？大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的EventBus会被移除，这样就导致业务走不下去。还有就是如果业务有反复操作的页面，EventBus在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理EventBus在项目中的关系。通常会用到，在vue页面销毁时，同时移除EventBus事件监听。

二、如果刷新页面，如何保障 vuex 的信息不丢失？

	在 beforeunload 事件里将当前 vuex 里的状态保存到 sessionStorage 里面，等页面重新加载之后从 sessionStorage 恢复即可。


五、nextTick原理
	https://www.cnblogs.com/liuhao-web/p/8919623.html
	vue在2.5版本中已经删去了 MutationObserver 相关的代码，因为它是 HTML5 新增的特性，在 iOS 上尚有 bug。
	macrotask 降级的方案依次是：setImmediate、MessageChannel、setTimeout。
	setImmediate 是最理想的方案了，可惜的是只有 IE 和 nodejs 支持。

	var channel = new MessageChannel();
	var port1 = channel.port1;
	var port2 = channel.port2;
	port1.onmessage = function (event) {
		console.log("port1收到来自port2的数据：" + event.data);
	}
	port2.onmessage = function (event) {
		console.log("port2收到来自port1的数据：" + event.data);
	}

	port1.postMessage("发送给port2");
	port2.postMessage("发送给port1");

 
六、生命周期函数  https://juejin.im/post/5b41bdef6fb9a04fe63765f1

	new Vue() 
	
	初始化事件和生命周期，执行beforeCreate

	挂载数据，绑定事件等等，执行created

	编译模板为虚拟dom放入到render函数中准备渲染，执行beforeMount

	渲染出真实dom，执行mounted钩子函数

	当组件或实例的数据更改之后，执行beforeUpdate

	当更新完成后，执行updated

	当经过某种途径调用$destroy方法后，执行beforeDestroy

	组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行destroyed

	1.ajax 请求最好放在 created 里面，页面可以访问到 this 了
	2.关于dom的操作要放在 mounted 里面，在mounted前面还没有生成 dom
	3.每次进入/离开组件都要做一些事情，用什么钩子函数：
		不缓存：进入的时候可以用 created 和 mounted 钩子，离开的时候可以使用 beforeDestroy（可以访问this）和destroyed

		缓存：缓存了组件之后，再次进入组件不会触发beforeCreate，created, beforeMount,mounted
		      如果你想每次进入组件都做一些事情的话，你可以放在 activated 进入缓存组件的钩子中


七、keep-alive

	在被keep-alive包含的组件/路由，会多出两个生命周期：activated 和 deactivated
	activated 在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用 调用机制：第一次进入缓存路由/组件，在mounted后面，beforeRouteEnter守卫传给 next 的回调函数之前调用：



九、模块化

	基本概念： 
		1.在js中，一个模块就是实现特定功能的文件(js文件) 
		2.遵循模块的机制，想要什么就加载什么模块
		3.模块化开发需要遵循规范

	js实现模块化规范
		require 是 CommonJs 规范引入方式
		import 是 es6 的一个语法标准，如果要兼容浏览器的话必须转化成 es5 的语法

		require 是运行时调用
		import 是编译时调用

		require 是赋值过程
		import 是解构过程

	解决的问题：1.命名冲突 2.文件依赖 3.模块的复用 4.统一规范和开发方式


十、谈谈Vue和React组件化的思想

	组件分为 UI 组件、业务组件等，主要是为了提取公共部分，避免了逻辑的重复，提高了生产效率，同时便于维护。


十一、vue的依赖收集和watch原理、computed原理
	https://zhuanlan.zhihu.com/p/53220088
	https://zhuanlan.zhihu.com/p/53219652
	
	Vue为数据中的每一个key维护一个订阅者列表。他是通过Object.defineProperty来劫持属性的 get 和 set，以此来为对应的key收集订阅者，并在值改变时通知对应的订阅者。

	computed：当我们需要进行一些简单的数值计算，并且依赖到其他属性值的时候，可以用 computed，它可以缓存计算结果，而不需要每次计算，当依赖的属性值改变时，我们在下一次获取 computed 值的时候再重新计算。
	watch：是对属性值的监听回调，我们可以在回调函数里执行异步操作或者其他一些比较复杂的操作。


vue2.0和3.0的双向绑定原理
	vue2：Object.defineProperty，只能追踪对象已有属性是否被修改，无法追踪新增属性和删除属性；
	对于数组无法监听数据的变化；
	vue在实现数组的响应式时，通过对数组的变更方法进行了包裹，所以它们也将会触发视图更新来实现响应式，这也只限制在数组的push/pop/shift/unshift/splice/sort/reverse七个方法。
	vue3：Proxy，Proxy直接代理整个对象而非对象属性，Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。


手写一个响应式
	https://www.cnblogs.com/bejamin/p/13493226.html 
	核心代码是用 Object.defineProperty 劫持对象的 get 和 set，在 get 里用 dep 来收集依赖，数据变化触发 set，在 set 里 notify 订阅者，然后订阅者执行 update 去更新；
	但是对于数组，数据变化并不能触发 set，所以 vue 2.0 对数组的响应式处理是对它的七个变异方法进行包裹，然后在包裹的方法里建立响应式，
	原理就是运用 Object.defineProperty 的数据描述符 value，我们先将 writable 设置为 true，这样的话，当数据被改变，就会运行 value 的回调函数，我们可以在这里去通知订阅者更新了。


vue-router传参方式及区别
	https://www.jb51.net/article/147142.htm 
	编程式：
	this.$router.push({ name: 'news', params: { userId: 123 }});    {{this.$route.params.userId}}
	this.$router.push({ path: '/news', query: { userId: 123 }});    {{this.$route.query.userId}}

	声明式：
	<router-link to="news"></router-link>
	<router-link :to="{ name: 'news', params: { userId: 1111}}"></router-link>
	<router-link :to="{ path: '/news', query: { userId: 1111}}"></router-link>

	客户端路由有两种实现方式：基于hash 和基于html5 history api.

	1.命名路由搭配params，刷新页面参数会丢失
	2.查询参数搭配query，刷新页面数据不会丢失
	二者还有点区别，可以理解为：query相当于get请求，页面跳转的时候，可以在地址栏看到请求参数，而params相当于post请求，参数不会在地址栏中显示

	$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法
	$route为当前router跳转对象（当前页面路由对象），里面可以获取name、path、query、params等


vue-router钩子函数
	https://www.cnblogs.com/qdlhj/p/9838426.html 
	全局导航钩子函数：
		router.beforeEach    应用场景，进入页面登录判断、管理员权限判断、浏览器判断
		router.afterEach

	路由独享的守卫(路由内钩子)
		beforeEnter 

	组件内的守卫(组件内钩子)
		beforeRouteEnter、
		beforeRouteUpdate、
		beforeRouteLeave    资源的释放，比如清理定时器，关闭弹窗等操作


前端路由是基于什么机制实现的，如果想使用history模式需要进行什么配置
	https://www.cnblogs.com/lguow/p/10921564.html 
	要实现前端路由，需要解决两个核心：
	如何改变 URL 却不引起页面刷新？
	如何检测 URL 变化了？
	下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。
	hash 实现

	hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新
	通过 onhashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过<a>标签改变 URL、通过 window.location.hash 改变URL，这几种情况改变 URL 都会触发 hashchange 事件
	history 实现

	history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新
	history 提供类似 onhashchange 事件的 onpopstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 onpopstate 事件，通过pushState/replaceState或<a>标签改变 URL 不会触发 onpopstate 事件。好在我们可以拦截 pushState/replaceState的调用和<a>标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。


用户权限校验
	https://blog.csdn.net/weixin_36094484/article/details/80405273 
	当用户发送请求时，我们先检查本地是存有用户凭证 token，没有的话就不执行请求而是先跳到登录页面，然后我们用账户密码登录之后，服务器会返回一个 token 给前端，同时还可以返回用户角色等信息，这样我们就知道用户对哪些页面和接口有访问权限。后续每次发请求就不用再重复登录，只要带上这个 token，然后服务器校验这个 token，如果正确有效，则返回数据。
	session-cookie 的方案：用户登录后服务器生成一个 session 保存用户状态，返回一个 sessionId 给客户端，这个 sessionId 是保存在 cookie 中的，后续每次访问都放在请求头提交给服务器进行校验。


vue如何自定义全局组件
	https://blog.csdn.net/second_boy/article/details/88727524
	https://www.cnblogs.com/zhaozhenzhen/p/12196613.html


重写element-ui样式
	如果是要全局性的修改样式的变量，则可以引入 theme-chalk 目录下的相关资源，然后修改对应的变量；
	如果只是在某个组件中修改，则先在浏览器中找到对应元素的类名，然后做单个的样式覆盖即可。


vue状态管理器的使用
	https://www.jianshu.com/p/2e5973fe1223
	state / mutations / getters / actions / modules

	首先入口文件里面引入store，然后再全局注入
	Vue.use(Vuex);
		const store = new Vuex.Store();
		export default store;
		new Vue({
		router,
	})
	使用：
	在state中定义数据；
	Getter相当于vue中的computed计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算，Getters 可以用于监听、state中的值的变化，返回计算后的结果；
	给action注册事件处理函数，当这个函数被触发时候，将状态提交到mutations中处理。actions里面自定义的函数接收一个context参数和要变化的形参；
	mutations是一个对象里。面的方法 都是同步事务，是更改state初始状态的唯一合法方法，具体的用法就是给里面的方法传入参数state或额外的参数；
	dispatch：含有异步操作，例如向后台提交数据，写法： this.$store.dispatch('action方法名',值)
	commit：同步操作，写法：this.$store.commit('mutations方法名',值)


vue 3.0
	https://www.cnblogs.com/yf-html/p/12753540.html
	1、性能更好了：重写了虚拟 dom 的实现、编译模板的优化、更高效的组件初始化、update 性能提升等；
	2、tree shaking：仅打包需要的模块；
	3、composition API：与 React Hooks 类似的东西，可以实现更灵活且无副作用的复用代码。2.0 时期，相关联的数据和逻辑可能会分别分布在 data、computed、methods 这几个地方，感觉非常散乱不易读；
	优点：更好的逻辑复用和代码组织、更好的类型推导。
	4、更好的 TS 支持；
	5、Custom Renderer API：

	Vue 3.0 中初始化状态通过 setup 方法，定义状态需要调用 ref 方法。接下来我们定义一个事件，用来更新 count 状态：
	const count = ref(0)
	const add = () => {
	count.value++
	}
	注意更新 count 值的时候不能直接使用 count++，而应使用 count.value++；
	import { ref, computed, watch } from ‘vue'


<h1 style="color:red">React</h1>			

Redux
	工具函数、applyMiddleware、createStore、bindActionCreators、combineReducers

一、react和vue的区别

	https://www.html.cn/qa/react/16384.html 
	1、vue 是数据双向绑定，react 单向数据流；
	2、vue 默认是 template 的写法，单文件组件，react 是 JSX + inline style，它把 html 和 css 全部写进了 js；
	3、vue 入门更简单一些，模板的写法有点类似 html，更好上手，react 可能稍微学习曲线陡峭一些；
	4、react 的生态要比 vue 好；


二、redux中的reducer（纯函数）

	Redux数据流里，reducers其实是根据之前的状态（previous state）和现有的action（current action）更新state(这个state可以理解为上下累加器的结果）
	每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身消减'(reduce),进而返回最新的state,这也就是典型reduce函数的用法：state ->  action ->  state


三、react的refs

	refs就像一个逃生窗，允许我们直接访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，
	它将接受地城dom元素或组件的已挂载实例，作为第一个参数


四、react中的keys

	帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它


五、React的生命周期

	三个状态：Mounting(已插入真实的DOM）
		  Updating(正在被重新渲染)
		  Unmounting(已移除真实的DOM)
	componentDIdMount 在第一次渲染后调用，只在客户端。之后组件已经生成对应的DOM结构，
	componentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用


六、React子组件向父组件传值

	父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。


七、React数据流


八、为什么虚拟DOM会提高性能 https://www.zhihu.com/question/29504639?sort=created

	当同一时间有多次DOM操作的时候，如果每次都立马操作DOM，则性能比较不好，
	虚拟DOM其实就是一个js对象，它会先将所有对DOM的操作记录到这个对象里，然后运用diff算法来算出具体是哪些DOM需要更新，然后一次性更新，大大提高了性能。

九、diff算法

	1.把树形结构按照层级分解，只比较同级元素
	2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记
	3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面
	Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用
	react只会匹配相同的class的component（这里的class指的是组件的名字）
	合并操作，调用component的setState方法的时候，React将其标记为dirty.到每一个时间循环结束，React检查所有标记dirty的component重新绘制
	4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能	


十、super


十一、简述下flux的思想

	flux的最大特点，就是数据的‘单向流动’
	1.用户访问View
	2.View发出用户的Action
	3.Dispatcher收到Action,要求state进行相应的更新
	4.store更新后，发出一个‘change’事件后，更新页面


十二、reac性能优化是哪个周期函

	shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，
	如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能


十三、react怎么划分业务组件和技术组件

	根据组件的职责通常把组件分为UI组件和容器组件
	UI组件负责UI的呈现，容器组件负责管理数据和逻辑
	两者通过React-redux提供connect方法联系起来


<h1 style="color:red">微信小程序</h1>		

https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/
https://www.cnblogs.com/teahouse/p/11504361.html
https://blog.csdn.net/z591102/article/details/105135385


小程序 this.setData 原理：
	https://www.cnblogs.com/hjj2ldq/p/9146032.html 
	针对单个属性的 setData，转成字符串，然后用中括号括起来。


小程序性能优化：
	1、图片放在cdn，图片过多则懒加载（image标签里的lazy-load属性、Intersection Observer API）；
	2、控制包的大小，采用分包策略；
	3、分包预加载（配置 preloadRule）；
	4、对于加载耗时较长的页面，先显示一个骨架结构；
	5、请求结果放在缓存中, 下次接着用，利用 storeage API 对；
	6、先反馈，再请求。比如说，点赞的按钮，可以先改变按钮的样式，再发起异步请求；
	7、减少 setData 的数据量，控制 setData 的次数，onscroll 里面慎用 setData，还可以用节流函数来进行控制等。
	8、异步请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据；


小程序限制：
	https://blog.csdn.net/weixin_34356138/article/details/89618545 
	1、单个包大小不能超过 2M，所有包总大小不超过 16M；
	2、不能发朋友圈；
	3、不支持长按识别普通二维码；
	4、不支持跳转其他h5；
	5、无法操作dom；


调用原生能力：
	1、图像接口；
	2、音频接口；
	3、地理位置；
	4、微信扫一扫；


小程序不能直接使用 svg，要先转换成 base64，然后在样式文件里定义背景图：
	https://blog.csdn.net/rolan1993/article/details/79863422 


小程序支付流程：
	服务端先调用小程序登录API，返回Openid，生成商户订单，调用支付统一下单API，返回预付单ID，经过处理将 timeStamp、nonceStr、package、signType、paySign 等参数返回给前端，
	然后调用 wx.requestPayment 接口。


小程序登录流程：
	调用 wx.login 获取 code，传给后台，后台拿着 appid + appsecret + code 到微信后台获取 session_key 和 openid，并自定义登录态与之关联，
	然后将登录态返回给前端，前端保存这个登录态，并在后续每次请求的时候都带上这个登录态。


<h1 style="color:red">性能优化</h1>						

项目性能优化
	https://www.jianshu.com/p/def55b3aef81 
	https://www.cnblogs.com/afterwawa/p/9439547.html 
	1、webpack 对图片进行压缩（image-webpack-loader）
	2、对于第三方资源包在 webpack 中配置 externals，然后将使用 CDN 资源的标签插入到页面
	3、对 webpack 构建结果进行分析，借助 webpack-bundle-analyzer 图形化工具，可以查看到哪些包过大，需要优化或者拆分。
	4、图片资源懒加载
	5、路由懒加载（在路由配置那里，component 属性赋值一个匿名函数，函数里 import 相关组件。）
	6、用 prefetch 预加载（<link rel='dns-prefetch' href='http://fls-na.amazon.com'>）
	7、浏览器缓存的使用（强缓存、协商缓存）
	8、服务器缓存（比如在 nginx 上配置 expires）
	9、开启 gzip 压缩
	10、优化无限加载列表
	11、事件的销毁，event bus 使用之后，记得在页面销毁之前解绑事件
	12、对于纯展示的列表数据，可以用 Object.freeze 来冻结对象，这样 vue 就不会为它实现响应式了
	13、keep-alive 的使用
	14、使用  Chrome Performance 查找性能瓶颈（可以录制一段时间内的 js 执行细节及时间）


一、webpack打包文件体积过大？（最终打包为一个js文件）

	1.使用路由懒加载进行分包
	2.提取第三方库
	3.代码压缩
	4.去除不必要的插件 tree-shaking
	5.使用CommonsChunkPlugin 提取多个chunk之间的通用模块，减少总体代码体积

	如何优化webpack构建的性能
		1、第三方库使用 CDN，避免每次编译过程都由Webpack处理
		2、减少目录检索范围，通过指定exclude和include选项，减少loader遍历的目录范围
		3、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias


Webpack
	webpack从入口开始，把入口文件引用到的所有模块和资源，以及模块引用到的模块，统统经过 loaders 和 plugins 处理并最终打包成 html、js、css 的流程。
	https://www.webpackjs.com/concepts/
	四个大模块：
	0、mode；// production / development
	1、entry；
	2、output；
	3、loader；loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。Loaders是用来告诉webpack如何转化处理某一类型的文件。pipe/compose
	4、plugins；插件的作用：从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。插件目的在于解决 loader 无法实现的其他事。我们可以通过 plugins 在打包的各个生命周期对模块进行操作。 https://www.webpackjs.com/plugins/
	如何写一个插件：定义一个 apply 方法；afterPlugins、beforeRun、run、compile、make、emit、done；


webpack 代码分割要配置什么？
	optimization.splitChunks.cacheGroups
	https://www.jianshu.com/p/c42a817dc8cf


webpack 异步加载原理？
	jsonp，在页面插入 script 标签


hash。所有的 bundle 使用同一个 hash 值，跟每一次 webpack 打包的过程有关
chunkhash。根据每一个 chunk 的内容进行 hash，同一个 chunk 的所有 bundle 产物的 hash 值是一样的。因此若其中一个 bundle 的修改，同一 chunk 的所有产物 hash 也会被修改。
contenthash。计算与文件内容本身相关。


webpack 常用的 loaders 和 plugins：
	vue-loader、babel-loader 等可以将特定文件格式转成js模块、将其他语言转化为js语言和编译下一代js语言；
	file-loader、url-loader等可以处理资源，file-loader可以复制和放置资源位置，并可以指定文件名模板，用hash命名更好利用缓存；
	url-loader可以将小于配置limit大小的文件转换成内敛Data Url的方式，减少请求；
	raw-loader可以将文件以字符串的形式返回；
	css-loader：会处理 import / require（） 引入的内容。
	style-loader：动态创建style标签，塞到head标签里。

	首先webpack内置UglifyJsPlugin，压缩和混淆代码；
	webpack内置CommonsChunkPlugin，提高打包效率，将第三方库和业务代码分开打包；
	html-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件；
	extract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件；
	DefinePlugin 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用；
	HotModuleReplacementPlugin 热更新，工作原理：热更新开启后，webpack-dev-server 会启动一个 HMR 服务器，同时会向浏览器注入 HMR runtime，然后这个 runtime 和 HMR 服务器通过 websocket 进行通信，当 webpack 检测到文件修改后，会重新构建，并通过 websocket 向浏览器发送更新消息，浏览器通过 jsonp 拉取更新过的模块，然后更新；


五、移动端300ms延迟

	由来：300毫秒延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放至原始比例。
	    由于用户可以双击缩放或者是滚动的操作，当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作
	    因此，safair浏览器就会等待300ms，用来判断用户是否再次点击了屏幕
	解决方案：
		1.禁用缩放，设置meta标签 user-scalable=no
		2.fastclick.js
	原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即发出click事件，并把浏览器在300ms之后真正的click事件阻止掉
	fastclick.js还可以解决穿透问题



<h1 style="color:red">服务器端</h1>

							
一、状态码：

      2XX（成功处理了请求状态）
          200 服务器已经成功处理请求，并提供了请求的网页
          201 Created 创建资源成功
          202 一个请求已经进入后台
          204 No Content
		  如果导航到的URL返回了一个没有响应体的HTTP/200响应,则页面将会显示一个空白文档(就是一片白色).页面的URL地址也会变成新指定的URL.
		如果服务器返回的是一个HTTP/204响应,当前页面不会有任何变化,就好像根本没有进行导航操作一样.页面的URL地址也保持不变.
		  206 Partial Content，进行范围请求

      3XX（每次请求使用的重定向不要超过5次）
	      301 永久性转移
		  302 暂时性转移
          304 网页上次请求没有更新，节省带宽和开销
      4XX（表示请求可能出错，妨碍了服务器的处理）
          400 服务器不理解请求的语法
          401 用户没有权限（用户名，密码输入错误）
          403 用户得到授权（401相反），但是访问被禁止
          404 服务器找不到请求的网页，
      5XX（表示服务器在处理请求的时候发生内部错误）
          500 服务器遇到错误，无法完成请求
          503 服务器目前无法使用（超载或停机维护）


二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销

	https://www.cnblogs.com/garfieldzhong/p/12498121.html
	https://www.cnblogs.com/wonyun/p/5524617.html
	1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）
	2.304是	HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去找浏览器缓存的文件
	3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tag客户端渲染该页面，并把Tag也存储在缓存中。客户端再次请求页面A
		并将上次请求的资源和ETag一起传递给服务器。服务器检查Tag.并且判断出该页面自上次客户端请求之后未被修改。直接返回304
	
	last-modified: 客户端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间
		客户端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，
		询问该事件之后文件是否被修改，没修改返回304

	有了Last-Modified，为什么还要用ETag？
		1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）
		2、某些服务器不能精确的得到文件的最后修改时间
		3、一些文件也许会周期性的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get
    
    ETag，为什么还要用Last-Modified？
		1、两者互补，ETag的判断缺陷，比如一些图片等静态文件的修改
		2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。

    ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
		1、ETag的值是服务器端对文件的索引节，大小和最后的修改的时间进行Hash后得到的。

	对于经常变动的文件，设置 Cache-Control: no-cache
	不常变化的资源，设置 Cache-Control: max-age=31536000


三、get/post 的区别

	1.get 数据是存放在 url 之后，以 '?' 分割 url 和传输数据，参数之间以 & 相连； post 方法是把提交的数据放在 http 包的 Body 中
	2.get 提交的数据大小有限制，（因为浏览器对 url 的长度有限制），post 的方法提交的数据没有限制
	3.get 需要 request.queryString 来获取变量的值，而 post 方式通过 request.from 来获取变量的值
	4.get 的方法提交数据，会带来安全问题，比如登录一个页面，通过 get 的方式提交数据，用户名和密码就会出现在url上


四、http协议的理解

	1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
	2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
	3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
	4.http请求信息request：
		accept、accept-encoding、accept-language、cookie、if-modified-since、if-none-match、user-agent、Host、Connection
		请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
		请求头部，用来说明服务器要使用的附加信息
		空行，请求头部后面的空行是必须的
		请求数据也叫主体，可以添加任意的其他数据。
	5.http响应信息Response
		Accept-Ranges、Content-Length、Content-Type、Date、ETag、Expires、Cache-Control、Last-Modified、Server
		状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
		消息报头，用来说明客户端要使用的一些附加信息
		空行，消息报头后面的空行是必须的
		响应正文，服务器返回给客户端的文本信息。


五、http和https

	https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密
	http：超文本传输协议。是一个客户端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少


六、http1.0 1.1 2.0的区别
	https://blog.csdn.net/xiaoming100001/article/details/81109617

	长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTTP1.1默认支持长连接
	节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
	host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域

	1.http2采用的二进制传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
	2.头部压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
	3.多路复用：一个连接可以并发处理多个请求
	4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端。通过在应用生成HTTP 回应的头信息中设置Link命令（推荐），服务器在收到包含Link的头信息时，就会进行推送,


http2 头部压缩的原理：
	使用 HPACK 算法进行压缩，这种算法通过在客户端和服务端各自维护索引表来实现，索引表又分为静态表和动态表，
	静态表中定义了61个Header字段（method、path）与 Index，可以通过传输 Index 进而获取 Header 的字段与值，极大减少了报文大小，
	动态表结构与静态表相同，可随时更新，索引表中不存在 header 信息的使用 huffman 编码进行传输，然后两端各自都更新到动态表中，到下一次通信的时候就只要传 index 了。
	（Header 传输以二进制桢的方式进行，为了与 HTTP1 中 Header 区分，这些以冒号开头的字段被称为“伪头字段”。）


八、常见的web安全及防护原理

	https://segmentfault.com/a/1190000019709041 

	XSS：跨站脚本攻击，原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。防范：a、设置白名单    b、用户的输入不可信，对于引号、尖括号、斜杠进行转义    c、将cookie属性设为HttpOnly，以避免cookie被客户端恶意JavaScript窃取。

	CSRF：即跨站请求伪造，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。防范：a、使用验证码    b、在HTTP 请求中以参数的形式加入一个随机产生的token，服务器读取浏览器当前域cookie中这个token值，进行比较校验。
	验证码：就是将一串随机产生的数字或符号，生成一幅图片， 图片里加上一些干扰象素，由用户肉眼识别其中的验证码信息，输入表单提交网站验证，验证成功后才能使用某项功能。 作用： 验证码一般是防止有人利用机器人自动批量注册、对特定的注册用户用特定程序暴力破解方式进行不断的登陆、灌水。

	SQL注入：有可能会造成获取数据库信息、管理员后台用户名和密码、读取服务器敏感文件等问题，甚至修改数据库内容。防范：a、对用户输入进行校验    b、不使用动态拼接sql。


九、CDN（内容分发网络）Content Delivery Network

	1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。
	2.关键技术：内容存储和分发技术
	3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术
		    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接响应用户的请求（全局负载技术）


十、TCP三次握手	(客户端和服务器端都需要确认各自可收发）

	客户端发起请求连接服务器端确认，服务器端也发起连接确认客户端确认。
	第一次握手：客户端发送一个请求连接，服务器端只能确认自己可以接受客户端发送的报文段
	第二次握手： 服务端向客户端发送一个链接，确认客户端收到自己发送的报文段
	第三次握手： 服务器端确认客户端收到了自己发送的报文段
	总的来说，三次握手是为了防止当已失效的连接请求报文段突然又传到服务端，造成双方的不一致，导致资源的浪费。

	A:“喂，你听得到吗？”A->SYN_SEND
	B:“我听得到呀，你听得到我吗？”应答与请求同时发出 B->SYN_RCVD | A->ESTABLISHED
	A:“我能听到你，今天balabala……”B->ESTABLISHED

	四次挥手：
	（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
	（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
	（3） 服务器关闭客户端的连接，发送一个FIN给客户端。
	（4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。


十一、从输入url到获取页面的完整过程  https://blog.csdn.net/samjustin1/article/details/52650520
	在进入到新页面之前会执行 beforeunload，可以做一些数据清理之类的工作。
	查询本地缓存，如果有缓存数据，则直接返回缓存数据，如果没有则进入网络请求流程。
	1.查询DNS(域名解析),获取域名对应的IP地址，如果请求协议是 HTTPS，那么还需要建立 TLS 连接。
	2.浏览器与服务器建立tcp链接（三次握手）
	3.浏览器向服务器发送http请求(请求和传输数据）
	4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器
	5.然后浏览器会判断状态码，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，如果是 200 则开始解析html。
	6.如果有遇到 script 标签、link 标签和图片等资源的话，也需要发送请求加载这些资源。
	7.然后根据 HTML 构建 DOM 树，有CSS的话会去构建 CSSOM 树，CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，然后是布局和绘制出来。

	tls 握手其实是一个密钥协商的过程：
	1、客户端将支持的加密算法和一个随机数 Client random 发给服务端；
	2、服务端选择一种加密算法，也生成一个随机数 Server random，然后和数字证书、非对称加密的公钥发送给客户端；
	3、客户端验证数字证书，如果有效，则再生成一个随机数 Premaster secret，并用服务端发来的公钥加密，发送给服务端，服务端用私钥解密，然后用这三个随机数一起通过某种算法生成协商秘钥；
	4、客户端用这三个随机数生成一个协商秘钥，并利用这个协商秘钥将之前所有通信参数的 hash 值与其它相关信息生成的数据进行加密，然后发送给服务器验证;
	5、服务端用协商秘钥解密并验证数据和秘钥的正确性，验证通过后，服务端发送一个消息告诉客户端后续的通讯都采用这个协商秘钥加密，然后	服务端也采用同样的方式发送一段加密的数据发给客户端进行验证，客户端验证通过后则握手完成。


十二、浏览器渲染原理及流程 DOM -> CSSOM -> render -> layout -> print

	https://blog.csdn.net/csdnnews/article/details/95267307
	3D transform属性会强制浏览器创建一个新的渲染层，它会跳过渲染流程的布局和绘制环节，只做渲染层的合并。

	流程：解析html以及构建dom树 -> 构建render树 ->  布局render树 -> 绘制render树
	概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树
	      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）
	      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置
	      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点
   
	重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上
		触发重绘的条件：改变元素外观属性。如：color，background-color等
		重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观
	注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花时间，要尽量避免使用table布局
	
	重排（重构/回流/reflow）： 当渲染树中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。
		每个页面都需要一次回流，就是页面第一次渲染的时候

	重排一定会影响重绘，但是重绘不一定会影响重排

	什么时候会引起回流：
		1.首当其冲自然是dom树结构变化，比如你删除或者添加某个node.
		2.元素几何属性变化，包括margin,padding,height,width,border等
		3.页面渲染初始化
		4.获取某些属性。
		5.浏览器窗口发生变化-resize事件发生时
	
	如何避免：
		1.将那些改变样式的操作集合在一次完事，直接改变className或者cssText
		2.让要操作的元素进行离线处理，处理完事以后再一起更新（DocumentFragment）
		3.不要经常访问会引起浏览器flush队列的属性，非要高频访问的话建议缓存到变量；
		4.将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位；
		5.尽量不要使用表格布局，如果没有定宽表格一列的宽度由最宽的一列决定，那么很可能在最后一行的宽度超出之前的列宽，引起整体回流造成table可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。


十三、为什么css放在顶部而js写在后面

	1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了
	2.其实HTML渲染并不会等到完全加载完再渲染页面，而是一边解析DOM一边渲染。
	3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加快的加载，提高用户的良好体验

	但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分别对待，把渲染页面的js放在前面，事件处理的js放在后面


十四、存储方式与传输方式

	1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。250m
	2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响
	3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客户端，保存为cookie）
	4.localStroage: h5的本地存储，数据永久保存在客户端

    1、cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上
       实际上浏览器和服务器之间仅需传递session id即可，服务器根据session-id找到对应的用户session对象
        session存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据
    2、cookie数据始终在同源的http请求中携带，在浏览器和服务器来回传递，里面存放着session-id
       sessionStorage，localStorage仅在本地保存
    3、大小限制区别，cookie数据不超过4kb，localStorage在谷歌浏览中2.6MB
    4、数据有效期不同，cookie在设置的（服务器设置）有效期内有效，不管窗口和浏览器关闭
      sessionStorage仅在当前浏览器窗口关闭前有效，关闭即销毁（临时存储）
      localStorage始终有效


	SessionStorage和localStorage区别：
		1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中）
		并且在会话结束后数据也随之销毁，不是一个持久的本地存储，会话级别的储存
		2.localStorage用于持久化的本地存储，除非主动删除数据，否则不会过期

	token、cookie、session三者的理解？？？！！！
		1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）
			用户身份的验证方式    

		2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次再登录某个网站，就会自动调用cookie自动登录用户名
			服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）

		3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）
			cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。

    基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）
		1、用户通过用户名和密码发送请求
		2、服务器端验证
		3、服务器端返回一个带签名的token，给客户端
		4、客户端储存token，并且每次用于发送请求
		5、服务器验证token并且返回数据
		每一次请求都需要token

    cookie与session区别
		1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
		2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。
		3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。
		4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

    session与token区别
		1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App
		2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，
			token不能转移到其他的App，也不能转到其他用户上。（适用于App）
		3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的

    Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）
		1、数量和长度的限制。每个特定的域名下最多生成20个cookie（chorme和safari没有限制）
		2、安全性问题。



<h1 style="color:red">设计模式</h1>
						
单例模式：比如 JQuery https://www.jianshu.com/p/df130352d2ed 
工厂模式：https://www.cnblogs.com/wzndkj/p/11756589.html 
设计原则：构造函数和创建者分离、符合开放封闭原则
window.$ = function(selector) {
    return new jQuery(selector);
}
发布订阅者模式等。


一、观察者模式：https://juejin.im/post/5a14e9edf265da4312808d86   https://juejin.im/post/5af05d406fb9a07a9e4d2799
	在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系
	简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subject,用来维护Observers,为某些event来通知（notify）观察者

二、发布-订阅者  有一个信息中介，过滤 耦合性低
	它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。

两者的区别：
	1.观察者模式中，观察者知道Subject ,两者是相关联的，而发布订阅者只有通过信息代理进行通信
	2.在发布订阅模式中，组件是松散耦合的。正好和观察者模式相反。
	3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的。
	4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。



<h1 style="color:red">数据结构和算法</h1>
						 	

一、两个栈实现一个队列，两个队列实现一个栈 https://www.cnblogs.com/MrListening/p/5697459.html

二、红黑树（解决二叉树依次插入多个节点时的线型排列） https://juejin.im/post/5a27c6946fb9a04509096248

	二叉查找树特性：左子树的所有节点必须小于根节点，右子树所有节点必须大于根节点
	红黑树是一种特殊的二叉树
	1.节点是红色或黑色。
	2.根节点是黑色。
	3.每个叶子节点都是黑色的空节点（NIL节点）。
	4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
	5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。


三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）https://juejin.im/post/5a2ff8c651882533d0230a85

四、十大排序 
	1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。
	  实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个
		    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数
		    3.针对所有的元素重复以上的步骤，除了最后一个
		    4.重复步骤1-3，直到排序完成。
	2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾
	  实现过程：

	3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入
	  实现过程：1.从第一个元素开始，该元素可以认为已经被排序
		    2.取出下一个元素，在已排序的元素序列中冲后向前扫描
		    3.如果该元素（以排序）大于新元素，将元素向后移一位
		    4.在取出一个元素，比较之前的，直到找到自己适合的位置

	4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序

	1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现
	  实现过程：1.从数组中挑出一个元素，成为一个基准
		    2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）
			这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。
		    3.递归的把小于基准值的子数列和大于基准值元素的子数列排序
	算法实现： function quickSort (arr) {
			if （arr.length <= 1） {return arr}
			var destIndex = Math.floor(arr.length/2)
			var left = [], right = [];
			var dest = arr.splice(destIndex,1)[0];
			for (var i =0;i<arr.length;i++){
				if (arr[i]<dest) {
				left.push(arr[i])
				} else {
				right.push(arr[i]) }
			return quickSort(left).concat([dest],quickSort(right)
				

	2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。
	  实现过程：1.

五、数组去重 https://juejin.im/post/5aed6110518825671b026bed#heading-6 
	1.双重循环 （for）
	2.indexOf
	2.对象属性去重
	3.数组排序去重 最快O(logN)
	
六、字符串
	判断回文字符串：（递归的思想）
		1.字符串分隔，倒转，举例： 'fgfdhfdhfdhf'.split('').reverse().join('')
		2.字符串头部和尾部，逐次向中间检测 
		3.递归

七、二分查找（有序数组的查找）

	二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数
	1、一开始，数据范围覆盖整个数组。
	2、将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。
	3、就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T

	代码实现：
	function binarySearch(arr, target, start, end){
		var end = end || arr.length - 1
		var start = start || 0
		var m = Math.floor((start + end) / 2)

		if(arr[m] < target){
			binarySearch(arr, target, m + 1, end)
		}else if(arr[m] > target){
			binarySearch(arr, target, start, m - 1)
		}else{
			return m
		}
	}



<h1 style="color:red">手写代码</h1>
							

一、动手实现一个bind（原理通过apply，call）
	https://www.lagou.com/lgeduarticle/90903.html

	一句话概括：
		1.bind()返回一个新函数，并不会立即执行。
		2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数
		3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效
	
	Function.prototype.bind = function(context){
		//保存this，也就是调用bind的那个函数
		var self = this;
		var args = [...arguments].slice(1);
		var bound = function(){
			//将第一次的参数与此次传入的参数合并，调用self函数
			return self.apply(context, args.concat([...arguments]));
		}

		var F =  function () {}  // 在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程
		F.prototype = self.prototype;
		bound.prototype =  new F();

		return bound;
	}
	
	Function.prototype.myCall = function (ctx, ...args){
		ctx = Object(ctx) || window;
		var fn = Symbol();
		ctx[fn] = this;
		var result = ctx[fn](...args);
		return result;
	}

	Function.prototype.myApply = function (ctx, args){
		ctx = Object(ctx) || window;
		var fn = Symbol();
		ctx[fn] = this;
		var result;
		if(!args){
			result = ctx[fn]();
		}else{
			result = ctx[fn](...args);
		}
		return result;
	}	


二、 AJAX （异步的javascript和xml）

	ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎），使用户操作与服务器响应异步化。
	优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载
	      可以把前端服务器的任务转嫁到客户端来处理，减轻服务器负担，节省宽带
	劣势：不支持back。对搜索引擎的支持比较弱；不容易调试	
	怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，
	解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax
	function getData(url) {
		var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象
		xhr.open('get', url, true)  // 设置一个http请求，设置请求的方式，url以及验证身份，第三个参数表示是以同步还是以异步的方式
		xhr.send() //发送一个http请求
		xhr.onreadystatechange = function () {  //设置一个http请求状态的函数
			if (xhr.readyState == 4 && xhr.status == 200) {
				console.log(xhr.responseText)  // 获取异步调用返回的数据
			}
		}
  	}
  	Promise(getData(url)).resolve(data => data)

	AJAX状态码：
	 	0 - （未初始化）还没有调用send()方法
		1 - （载入）已调用send方法，正在发送请求
		2 - （载入完成）send()方法执行完成
		3 - （交互）正在解析响应内容
		4 - （完成）响应内容解析完成，可以在客户端调用了


三、函数节流（throttle）

	function throttle (func, wait) {
		var timeout;
		return function () {
			var context = this;
			var args = arguments;
			if (!timeout) {
				timeout = setTimeout(() => {
					timeout = null;
					func.apply(context,args)
				}, wait);
			}
		}
	}


四、函数防抖（dobounce）

	function debounce (func, wait) {
		var timeout;
		return function() {
			var context = this;
			var args = arguments;
			clearTimeout(timeout);
			timeout = setTimeout(() => {
				func.apply(context,args)
			}, wait);
		}
	}


 
六、实现一个简单的Promise https://juejin.im/post/5b2f02cd5188252b937548ab

	class Promise {
		constructor (executor) {   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。
			this.status = 'pending',
			this.value = undefined;
			this.reason = undefined;
			this.onResolvedCallbacks = [];
			this.onRejectedCallbacks = [];
			let resolve = (value) => {		// 这里一定要用箭头函数
				if (this.status == 'pending') {
					this.status = 'resolve';
					this.value = value;
					this.onResolvedCallbacks.forEach(fn => fn())
				}
			}

			let reject = (reason) => {
				if (this.status == 'pending') {
					this.status = 'reject';
					this.reason = reason;
					this.onRejectedCallbacks.forEach(fn => fn())
				}
			}
			try{
				executor(resolve, reject);
			} catch (err) {
				reject(err);
			}
		} 
		then (onFullFilled,onRejected) {
			if (this.status == 'resolved') {
				onFullFilled(this.value)
			}
			if (this.status == 'rejectd') {
				onRejected(this.reason);
			}
			if (this.status == 'pending') {
				this.onResolvedCallbacks.push(()=>{
					onFullFilled(this.value);
				})
				this.onRejectedCallbacks.push(()=> {
					onRejected(this.reason);
				})
			}
		
		}
	}

	const p = new Promise((resolve, reject) => {
		setTimeout(() => {
			resolve('hello world')
		}, 1000);
	})
	p.then((data) =>{
		console.log(data)
	},(err) =>{
		console.log(err);
	})


七、发布订阅者模式（观察者模式）

	class Observer {
		constructor() {
			this.clientList = {}
		}

		on(event, cb) {
			this.clientList[event] = this.clientList[event] || []
			this.clientList[event].push(cb)
		}

		emit(event) {
			this.clientList[event] = this.clientList[event] || []
			this.clientList[event].forEach(cb => cb())
		}
	}


	event.emit('event1')


八、手动写一个node服务器

	var http = require('http');  
	http.createServer(function (request, response) {  
		response.writeHead(200, {'Content-Type': 'text/plain'});  
		response.end('Hello World\n');  
	}).listen(8888);


九、浏览器兼容

	a、iphone及ipad下输入框默认内阴影 （-webkit-appearance:none;）
	b、圆角bug，某些Android手机圆角失效 background-clip:padding-box;
	c、上下拉动滚动条时卡顿、慢（-webkit-overflow-scrolling:touch;）
	d、position fixed 在ios上滑动不固定问题（1、方法一：将fixed定位的内容移出 滚动视图外 2、方法二：在使用position:fixed的元素上加上transform: translateZ(0);）
	e、new Date 传参区别。
	f、小程序 safeArea

	IE：trident内核（IE内核）
	Firefox：gecko内核，Mozilla自己开发的一套开放源代码、以C++编写的渲染引擎。
	Safari：webkit内核，开源的浏览器引擎，源自于Linux平台上的一个引擎，经过Apple公司的修改可以支持Mac与Windows平台。
	Chrome：Blink内核，Google和Opera Software共同研发。
	Opera：以前是presto内核，现在改为Blink内核。

	css 方面，css3（阴影、圆角、媒体查询、伪类选择器、iconfont） 要 IE9 以上才兼容。
	html 方面，placeholder、html5 标签（header、footer、nav、section）、Firefox点击链接出现的虚线框、部分浏览器 input 框默认样式、select 默认样式、图片默认间距
	js 方面，ES6/7，Promise、async/await、低版本浏览器 new Date 的日期参数不能是中横杠 '-' 连接的字符串、鼠标键值各不同、
	document.documentElement/document.body、
	addEventListener/atachEvent、
	event ? event : window.event
	event.target || event.srcElement、
	removeEventListener/detachEvent、
	event.stopProgation/event.cancelBubble、
	event.preventDefault/event.returnValue、
	event.x : event.pageX

	解决方案：
	IE条件注释、CSS hack
	CSS3媒体查询兼容方案：Respond.js
	CSS3字体单位“rem”兼容方案：rem.js
	HTML5标签兼容方案：html5shiv.js
	js：es5-shim.js
	JS数组的forEach方法


十二、加密解密：

	1.对称加密，加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。
	2.非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。
	3.解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。
	https://www.cnblogs.com/songmengyao/p/12302678.html

	常见的对称加密算法有DES、AES、3DES、Blowfish、IDEA、RC4、RC5、RC6
	常见的非对称加密算法有：RSA、DSA（数字签名用）、ECC（移动设备用）、Diffie-Hellman、El Gamal、


十三、断点续传

	https://www.jianshu.com/p/012c8a4dc661
	https://www.jianshu.com/p/012c8a4dc661
	HTTP1.1协议（RFC2616）中定义了断点续传相关的HTTP头 Range和Content-Range字段，一个最简单的断点续传实现大概如下：

	首先对要传输的文件进行 slice 切片，一片一片的传输，每传输完一片都在本地做好标记传到哪了，下次如果网络中断，恢复网络之后就知道要从哪里开始传了。
	文件传到一半，网络中断，之后客户端请求续传，需要在HTTP头中申明 Range:bytes=512000-，告诉服务端从哪里开始传，之后服务端在HTTP头中返回 Content-Range:bytes 512000-/1024000，HTTP状态码返回206。

	但是要注意的是，实际情况是传输的文件有可能已经改变了，需要用 Etag 和 Last-Modfied 去判断，如果没有文件没有改变，则正常续传，如果已经改变了，则从头开始传。


微信公众号 —— 授权登录流程
	2、页面转场动画，用 c3 设置样式（ transition 组件， transform: translate3d(100%, 0, 0) ），vue 提供的钩子：enter-active、enter、leave、leave-active。
	3、为了防止页面穿透（在当前页滚动页面会影响到其他页面），页面结构最外边包一个容器 page，设置 width: 100%;height: 100%;overflow: hidden;，然后里面包一个容器 page-content，设置  height: 100%;overflow: auto;


16.WEB应用从服务器主动推送Data到客户端有那些方式？

	a. html5 websoket
	b. WebSocket 通过 Flash
	c. XHR长时间连接
	d. XHR Multipart Streaming
	e. 不可见的Iframe
	f. 标签的长时间连接(可跨域)


25.AMD和CMD 规范的区别？
	https://blog.csdn.net/Mahuicool/article/details/86129376
	AMD 提前执行依赖 - 尽早执行，requireJS 是它的实现
	CMD 按需执行依赖 - 懒执行，seaJS 是它的实现



30.知道的网页制作会用到的图片格式有哪些？

	png-8，png-24，jpeg，gif，svg
	Webp：谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。
	Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准。


canvas和svg的区别
	https://www.jianshu.com/p/942d219b86d0 
	https://www.jianshu.com/p/737163c93c84 
	1、svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布；
	2、svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿。

	canvas 动画的原理是，比如一秒钟内 30帧 或 60帧 canvas 图片连贯的进行切换显示，形成一个动画效果，可以用定时器requestAnimationFrame 或者 setTimeout、setInterval 实现。
	canvas IE9 才兼容，requestAnimationFrame IE10 才兼容。
	canvas API：fillStyle、stroke、beginPath、moveTo、fillText、drawImage、save、restore等。


强缓存、协商缓存
	https://www.cnblogs.com/garfieldzhong/p/12498121.html
	https://www.cnblogs.com/wonyun/p/5524617.html


32.一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验[性能优化]。

a. 图片懒加载，滚动到相应位置才加载图片。
b. 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。
c. 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。
d. 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。

33.谈谈以前端角度出发做好SEO需要考虑什么？

a. 了解搜索引擎如何抓取网页和如何索引网页
b. meta标签优化
c. 关键词分析
d. 付费给搜索引擎
e. 链接交换和链接广泛度（Link Popularity）
f. 合理的标签使用


function deepCopy (obj, cache = []) {

  // just return if obj is immutable value
  if (obj === null || typeof obj !== 'object' || Object.prototype.toString.call(obj) === '[object RegExp]') {
    return obj
  }

  const hit = cache.filter(c => c.original === obj)[0]
  if (hit) {
    return hit.copy
  }

  const copy = Array.isArray(obj) ? [] : {}
  // put the copy into cache at first
  // because we want to refer it in recursive deepCopy
  cache.push({
    original: obj,
    copy
  })

  Object.keys(obj).forEach(key => {
    copy[key] = deepCopy(obj[key], cache)
  })

  return copy
}

mocha:
describe('测试 util.js', () => {
  it('isIE 方法', () => {
    expect(isIE()).to.be.false
  })
})


1 git init                   把当前的目录变成git仓库，生成隐藏.git文件。
2 git remote add origin url  把本地仓库的内容推送到GitHub仓库。
3 git clone git@url/test.git 从远程库克隆
4 git add *                  把x文件添加到暂存区去。
5 git commit –m "*"          提交文件 –m 后面的是注释。   


过往项目介绍
	以我之前做的小程序项目为例，给用户提供了线上订房服务，大致包含首页，产品列表，产品详情，下单，订单管理等页面。
	我们这个项目是采用原生小程序开发的，因为原生开发有一些局限性，比如不支持 scss 样式预处理、ES6支持度不高，没有状态管理等等，
	所以第一步我们首先引入 webpack 构建工具，小程序的 webpack 配置文件可能稍微麻烦一点的地方是要找出所有的文件打包入口，首先从 app.json 开始，找到里面所有的页面、组件、tabbar、还有分包里面的页面路径，然后再递归的去找这些页面和组件所引用到组件，把所有这些路径下后缀为 .wxml、.js、.scss、.json 的文件作为打包入口进行打包。然后就是配置 loaders、plugins、splitchunks（optimization.splitChunks.cacheGroups） 等。

	第二步，我们把项目包含的几个主要目录规划好，大概有 
	api（我们把所有的 api 都封装在这个目录，我们的 api 是基于 axios 进行进一步的封装，定义了基本方法 post、get、delete 等，然后定义了请求拦截，比如请求前后各做一些事情 axios.interceptors.request、axios.interceptors.response）、
	assets（静态资源放在这里，图片什么的）、
	components（比如 tabbar、popup、authorized-button 之类的一些公共组件，// 我们内部封装了一套 UI 组件，包括常用的 button、badge、input 这些，我们先是借鉴 antd 定义的那些变量规范，然后根据设计师给出的前端 UI 规范进行调整）、
	pages（页面，index 页面并不做实际的展示，它只负责登录并跳转）、
	constants（常量）、
	subpackages（分包限制 2M，所以将一些大的业务模块分包出去，比如订单中心、产品中心等）、
	store（在 redux 的基础上进行封装，然后导出两个重要的函数 connectPage、connectComponent，使用的时候，我们只要在页面中导入 connectPage ，然后用 connectPage 对页面参数进行处理，
	并传入 mapStateToProps 和 mapDispatchToProps，然后在 onLoad 钩子函数里将 mapStateToProps 映射到页面的 data 下，这样页面就能展示 store 里的数据了，同时 store 添加该页面对数据的监听，
	一旦数据在其他组件被修改，则执行监听函数，调用该页面的 setData 将相关数据更新到本页面；另一方面，我们再把 mapDispatchToProps 映射到页面的 methods 下，一旦该页面对 store 里的数据有改动，
	则将改动后的数据 dispatch 到 store，使之更新。然后我们还需要在页面的 onUnload 钩子函数里注销事件的监听；而用于 connectComponent 也差不多，只不过对应的钩子函数是 lifetimes 下的 attached 和 detached 而已。

	用到的 loaders 大概有：
	babel-loader：ES6
	sass-loader：scss
	wxml-loader：wxml
	file-loader：

	用到的 Plugins 大概有：
	BannerPlugin：在入口 js 文件的头部插入公共代码
	DefinePlugin


对 ES7/8/9 有了解吗，简单说一下；
	https://blog.csdn.net/weixin_43720095/article/details/89432584 
	https://www.cnblogs.com/zhoujie/p/node1.html 
	ES6：类、模块化、箭头函数、函数参数默认值、模板字符串、解构赋值、延展操作符、Promise、Let、Const；
	ES7：Array.prototype.includes
	ES8：async/await、Object.values、Object.entries
	ES9：对象解构、Promise.finally


es6中用的较多的功能有哪些
	let、const、Symbol、对象的解构、字符串模板、Promise、Class、Set、Map 等。
	let：不会变量提升，有块作用域，同一个块作用域下不能多次声明，const在此基础上，声明的时候要初始化，后续不能改变其值。
	Symbol，表示独一无二的值。（字符串容易造成属性名的冲突）。
	Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
	Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
	WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。
	WeakMap 的键值只能是对象，而不能是其他类型的值。应用的典型场合就是 DOM 节点作为键名。一旦这个 DOM 节点删除，对应的状态就会自动消失，不存在内存泄漏风险。


微任务、宏任务
	https://www.cnblogs.com/amiezhang/p/11349450.html
	https://www.jianshu.com/p/a7550c0e164f
	JS是单线程，虽然有webworker酱紫的多线程出现，但也是在主线程的控制下。webworker仅仅能进行计算任务，不能操作DOM，所以本质上还是单线程。


上滑加载下一页数据实现细节
	scrollHeight - scrollTop - clientHeight 


css哪些可继承，哪些不可继承？
	不可继承的：display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi。
	所有zhi元素可继承：visibility和cursor。
	内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。
	块状元素可继承：text-indent和text-align。
	列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。
	表格元素可继承：border-collapse。


lodash 如何实现模块加载？
	http://www.manongjc.com/detail/7-kgezfdqvajmtoof.html 
	借助于lodash-webpack-plugin，去除未引入的模块，需要和babel-plugin-lodash插件配合使用。类似于webpack的tree-shaking。


proxy 如何实现对 set、map 的劫持：
	https://juejin.im/post/6844904050912133133 
	https://my.oschina.net/sl1673495/blog/4439245 

Reflect:
	https://es6.ruanyifeng.com/#docs/reflect 
	ES6 新语法，将Object对象一些属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。
	修改某些Object方法的返回结果，让其变得更合理。比如以前是报错，现在是返回 false。
	让Object操作都变成函数行为。以前命令式的写法改成函数行为。
	Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。

Proxy.set拦截里面使用了Reflect.set，传入的receiver参数总是指向当前的 Proxy实例（即上例的obj），当我们就将属性赋值到receiver上面时（即obj），将会触发defineProperty拦截。


公共组件如果UI经常变动，如何封装？解耦？
	逻辑交互和 UI 不要耦合，比如今天是用 UI A，明天是用 UI B，那么我们可以把这部分可能会变动的 UI 部分设计成以 prop 的形式传入。


echarts:
	https://www.cnblogs.com/rebackl/p/12990874.html 
	https://blog.csdn.net/beam007/article/details/83654604 
	按需引入模块：
	// 引入 ECharts 主模块
	var echarts = require('echarts/lib/echarts');
	// 引入柱状图
	require('echarts/lib/chart/bar');
	// 引入提示框和标题组件
	require('echarts/lib/component/tooltip');
	require('echarts/lib/component/title');


前端面经：
	https://github.com/woai3c/Front-end-basic-knowledge 
	https://www.cnblogs.com/jinzhenzong/p/12345249.html 


Node 相关
	https://github.com/yisainan/web-interview/blob/master/content/js/node.md 
		1. 对node.js有什么了解？
	　　
	答案：它既是开发平台, 也是运行环境, 也是个新的语言...它本身是基于 google 的 javascript v8 引擎开发的, 因此在编写基于它的代码的时候使用javascript 语言. 但是又不同于传统概念的javascript...
	它的服务端功能以及部分客户端功能必须在服务端运行, 所以它实际上是一种在服务端的开发+运行的 javascript 语言. 有一点类似于 Perl + PHP 或者 Python 的概念. 它本身可以作为 HTTP Server, 也可以当作TCP Server 用.
	　　
	2 .Express 和 koa 有什么关系，有什么区别？
	　　
	答案：koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。 
	koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。koa 是一个比 express 更精简，使用 node 新特性的中间件框架，相比之前express 就是一个庞大的框架如果你喜欢DIY 很潮，
	可以考虑koa， 他有足够的的扩展和中间间，而且自己写很简单。如果你想简单点，找一个框架啥都有，那么先 express。
	　　
	3 .node.js 适合做什么业务？
	　　
	答案：Nodejs 是单线程，非阻塞 I/O，事件驱动，它的特点决定了它适合做一些大量 I/O 的东西，比如，聊天室，表单提交等不需要大量计算的功能。做一些微信后端开发，或者做消息系统等。
	可以整个项目用， 也可以根据它的特点在某个模块使用，比如 socketio，打造一个消息系统等。
	　　
	4 .node.js 与 php 和 Java 的区别。
	　　
	答案：Node.js 是前端中的一种技术，是单线程，非阻塞 I/O，事件驱动，是一门很强大的技术。 java，一直很牛 X，企业级别的项目，基本上都用这个，如果考虑长期发展，这个是首选，不过同时这个难度也是最大的，
	如果自己没有语言基础，这个和后面的一个，最好不要选择，你选择测试可能会更加好一点。 PHP 是一门脚本语言，基本都用在 web 应用中的中间层，负责数据库以及前台页面交互和信息传递。
	　　
	5． Nodejs 中的 Stream 和 Buffer 有什么区别？
	　　
	答案：Buffer：为数据缓冲对象，是一个类似数组结构的对象，可以通过指定开始写入的位置及写入的数据长度，往其中写入二进制数据。Stream：是对 buffer 对象的高级封装，其操作的底层还是 buffer 对象，
	stream 可以设置为可读、可写，或者既可读也可写，在 nodejs 中继承了 EventEmitter 接口，可以监听读入、写入的过程。具体实现有文件流，httpresponse 等。
	　　
	6．node 的异步问题是如何解决的？
	　　
	答案：模块化: 将回调函数转换为独立的函数使用流程控制库，例如 aync ，使用 Promise，使用 aync/await。

	对Node 的优点和缺点提出了自己的看法：
	（优点）因为Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
	因此构建在Node 上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
	此外，与Node 代理服务器交互的客户端代码是由javascript 语言编写的，
	因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。
	（缺点）Node 是一个相对新的开源项目，所以不太稳定，它总是一直在变，
	而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails 当年的样子。
	需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退
	时正确响应。给出你的技术实现方案？
	至少给出自己的思路（url-hash,可以使用已有的一些框架history.js 等）
	Node.js 的适用场景？
	1)、实时应用：如在线聊天，实时通知推送等等（如socket.io）
	2)、分布式应用：通过高效的并行I/O 使用已有的数据
	3)、工具类应用：海量的工具，小到前端压缩部署（如grunt），大到桌面图形界面应用程
	序
	4)、游戏类应用：游戏领域对实时和并发有很高的要求（如网易的pomelo 框架）
	5)、利用稳定接口提升Web 渲染能力
	6)、前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著
	名的纯Javascript 全栈式MEAN 架构）
	( 如果会用node) 知道route, middleware, cluster, nodemon, pm2,
	server-side rendering 么?
	Nodejs 相关概念的理解程度
	解释一下Backbone 的MVC 实现方式？
	流行的MVC 架构模式
	什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?
	熟悉前后端通信相关知识

	什么是前端路由：简单来说路由 就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不 同的资源，请求不同的页面是路由的其中一种功能。
	node 中间件：
	中间件就是一种功能的封装方式，用来处理http请求，它有一个next()函数，如果不调用next函数，请求就在这个中间件中终止了。
	express.static：用来返回静态文件的自带中间件
	body-parser：用于解析post数据
	multer：处理文件上传
	cookie-parser：用来操作cookie
	cookie-session：express中用于处理session的中间件
	cluster：node 使用 cluster 实现多进程，单个Nodejs实例在单线程环境下运行。为了更好的利用多核CPU环境，用户有时希望启动一批Node.js 进程用于加载。
	cluster.fork()
	https://www.jianshu.com/p/2e04bca6d0c5 

	nodemon 监听node代码变化的工具，会自动完成node服务器和数据库服务器的重启。
	PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。


项目回顾 - 直播
	authorized-button：它的作用是为了确保用户进行某个操作前已经授权用户信息，原理是对获取用户信息按钮（open-type="getUserInfo" ）进行封装，并将它覆盖在目标按钮上，
	如果当前已经登录，则隐藏这个获取用户信息的按钮，那么就能正常进行下一步流程，如果没有登录，则显示这个按钮，用户实际上就点击了这个获取用户信息的按钮，进入到获取用户信息授权的流程。

	live-player 传入对应播放流的 src 即可。
	live-pusher：从后台获取一个 rtmpPushUrl。
	直播间发消息我们是用的腾讯云即时通信IM SDK

	Behaviors
	wx.getSystemInfo 获取系统信息， iPhoneX，兼容顶部和底部

	项目回顾 - 封装 table
	公众号项目回顾
	最外面用一个 transition 组件，实现类似小程序的翻页动画效果（enter、leave、enter-active、leave-active），然后页面用 keep-alive 组件包裹进行缓存。rem.js 做自适应方案。


正则表达式
	g：全文查找        i：忽略大小写


未来职业规划
	先着眼于眼前的工作可能会更加实际一些，把工作中每次需求做好，尽可能的去承担更多，和团队一起协作顺利的达成工作目标。

	
与服务器端的对接
	前后端的开发之前应该约定传递的数据格式，然后前端开发的时候自己先 mock 一下，等后台接口开发完再对接和调整，然后测试。
	mockjs能做的事情是拦截Ajax请求，可以返回各种随机的数据。
	webpack 在开发环境下配置一个 plugin webpack.DefinePlugin({ MOCK: true })，DefinePlugin插件允许创建一个在编译时可以配置的全局变量，这样的话，我们就可以通过在入口文件判断这个 MOCK，如果为 true，说明是当前是开发环境，则把 mock.js require 进来，这样 mock 就能生效并拦截请求了。
	有条件可以搭建一个 Mock-Server 服务


代码维护
	https://zhuanlan.zhihu.com/p/141633166
	a、首先目录结构得组织好，assets、constants、pages、store、components 等几个大的目录，平时的代码和资源都按照这个大的框架组织好，不要七零八落。
	b、命名风格统一，比如目录和文件的命名，单词都小写，多个单词用中横杠隔开，常量命名要大写，多个单词用下划线隔开，变量命名用驼峰等等。
	c、给代码添加合理的注释，注释不是越多越好，一般只对一些复杂的、妥协的、还有处理兼容性的代码做好注释。
	d、合理的封装，比如后台管理系统可能多个页面都会用到 table 组件，并且一般会配合翻页和条件查询一起使用，这时候我们可以将他们封装在一起，使用的时候只要传入对应的配置项，即可生成一个带有翻页和相应查询条件项的表格界面。这样可以最大限度的做到代码风格统一而且简洁易维护。
	e、提取相同逻辑的代码，不要重复实现。
	f、模块化，开发页面的时候，对于比较复杂的页面，根据页面的结构划分出几个主要的模块，这样代码结构会更清晰，如果哪天需要修改某个模块或者要移除这个模块也是非常轻松的。


代码题：用es5的方式实现es6中的const（思路：Object.defineProperty 定义 configurable 和 enumerable 为 false）


工作中遇到什么难题
	技术上的难题倒还好，碰到的绝大部分技术问题基本可以通过查资料，向同事请教以及自己归纳总结就可以解决，
	像这种只需要通过自身的努力就可以解决的问题相对还容易些，稍微麻烦点的可能是你需要协调其他人一起达成某个目标，
	尤其是让你带着其他人负责一个前端项目的时候，需要考虑的以及碰到的问题会比较多，比如从开始的需求分析阶段，
	产品经理跟大家说，我们这次的迭代需要完成哪些功能，评估时间（开发时间、测试时间），需求不合理或者给的时间不够则沟通协调，沟通的技巧方式，原则等。
	开发阶段，如何分配任务，把控开发进度
	测试阶段，跟进测试，积极配合测试


如何与安卓和ios交互
	https://segmentfault.com/a/1190000016879200 
	https://www.fanjinyan.com/javascript/415 
	安卓通过调用相关 API 将 java 对象和 js 对象进行映射：
	js 调用安卓：window.JavascriptInterface.方法名()
	安卓调用 js：js 在 window 对象下定义一个方法即可。

	iOS 与 js：
	js 先要注册 Message Handlers，便有了 window.webkit.messageHandlers 对象，调用方法：window.webkit.messageHandlers.方法名.postMessage()
	iOS 调用 js：js 在 window 对象下定义一个方法即可。


前端缓存种类：
	https://www.jianshu.com/p/07e7f124ddf7 
